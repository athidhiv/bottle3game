<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body style="margin: 0; background: #222;">
<div id="endUI" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); color:white; flex-direction:column; align-items:center; justify-content:center; font-family: sans-serif; z-index:9999;">
    <h1 id="winnerText"></h1>
    <div id="statsBox" style="margin-top:20px; text-align:left;"></div>
    <button id="rematchbtn" onclick="playAgain()">REMATCH</button>
    <button onclick="goHome()">Back Home</button>
    <p id="rematchCount"></p>
</div>

<script>
let socket;
const roomName = sessionStorage.getItem("roomName");
const numPlayers = parseInt(sessionStorage.getItem("numPlayers"));
const playerName = sessionStorage.getItem("playerName");
let matchStartTime = 0;
let matchHistory = [];
let winCounts = {};
let lastSend = 0;
const SEND_RATE = 50; // ms ‚Üí 20 times/sec
const config = {
    type: Phaser.AUTO,
    scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: window.innerWidth,
        height: window.innerHeight
    },
    backgroundColor: "#000",
    physics: { default: "arcade", arcade: { debug: false } },
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);
function preload() {
    
    this.load.image("egg", "/assets/gold_egg.png");
}


function create() {
    const self = this;

    this.worldWidth = this.scale.width;
    this.worldHeight = this.scale.height;
    this.centerX = this.worldWidth / 2;
    this.centerY = this.worldHeight / 2;
    this.arenaRadius = Math.min(this.worldWidth, this.worldHeight) * 0.4;

    this.arena = this.add.circle(this.centerX, this.centerY, this.arenaRadius, 0x444444, 0.15)
        .setStrokeStyle(4, 0xffffff, 0.4);

            this.playerSize = this.arenaRadius * 0.09;
            this.playerSpeed = Math.min(this.worldWidth, this.worldHeight) * 0.004;
            this.joyBase = this.add.circle(0, 0, 60, 0x000000, 0.3)
            .setScrollFactor(0)
            .setDepth(1000)
            .setVisible(false);

        this.joyStick = this.add.circle(0, 0, 30, 0xffffff, 0.6)
            .setScrollFactor(0)
            .setDepth(1001)
            .setVisible(false);

        this.joyData = {
            active: false,
            forceX: 0,
            forceY: 0,
            max: 50
        };
this.input.on("pointerdown", pointer => {
    // Save for tap detection
    this.tapStart = { x: pointer.x, y: pointer.y };

    // Floating joystick
    this.joyBase.setPosition(pointer.x, pointer.y).setVisible(true);
    this.joyStick.setPosition(pointer.x, pointer.y).setVisible(true);

    this.joyData.active = true;
    this.joyData.startX = pointer.x;
    this.joyData.startY = pointer.y;
});
this.input.on("pointermove", pointer => {
    if (!this.joyData.active) return;

    const dx = pointer.x - this.joyData.startX;
    const dy = pointer.y - this.joyData.startY;
    const dist = Math.hypot(dx, dy);
    const max = this.joyData.max;

    if (dist > max) {
        const a = Math.atan2(dy, dx);
        this.joyStick.x = this.joyData.startX + Math.cos(a) * max;
        this.joyStick.y = this.joyData.startY + Math.sin(a) * max;
    } else {
        this.joyStick.x = pointer.x;
        this.joyStick.y = pointer.y;
    }

    this.joyData.forceX = (this.joyStick.x - this.joyData.startX) / max;
    this.joyData.forceY = (this.joyStick.y - this.joyData.startY) / max;
});

this.input.on("pointerup", pointer => {
    // --- joystick release ---
    this.joyBase.setVisible(false);
    this.joyStick.setVisible(false);

    this.joyData.active = false;
    this.joyData.forceX = 0;
    this.joyData.forceY = 0;

    // --- double tap grab ---
    if (!this.tapStart) return;

    const dx = pointer.x - this.tapStart.x;
    const dy = pointer.y - this.tapStart.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 20) {
        const now = Date.now();

        if (now - this.lastTapTime < 300) {
            socket.emit("toggleGrab");
            this.lastTapTime = 0;
        } else {
            this.lastTapTime = now;
        }
    }

    this.tapStart = null;
});

    // --- RESIZE HANDLER ---
    this.scale.on("resize", (gameSize) => {
        this.worldWidth = gameSize.width;
        this.worldHeight = gameSize.height;
        this.centerX = this.worldWidth / 2;
        this.centerY = this.worldHeight / 2;
        this.arenaRadius = Math.min(this.worldWidth, this.worldHeight) * 0.4;
        this.arena.setPosition(this.centerX, this.centerY).setRadius(this.arenaRadius);
        this.playerSize = this.arenaRadius * 0.09;
        this.playerSpeed = Math.min(this.worldWidth, this.worldHeight) * 0.004;

        // Update zones
        this.zones.forEach(zone => {
            zone.setPosition(this.centerX + zone.relX * this.arenaRadius, this.centerY + zone.relY * this.arenaRadius);
            zone.setRadius(zone.relR * this.arenaRadius);
            zone.countText.setPosition(zone.x, zone.y).setFontSize(zone.relR * this.arenaRadius * 0.6);
        });

        /// Update circles (SIZE ONLY)
        this.circles.forEach(c => {
            const size = this.arenaRadius * 0.08;
            c.baseSize = size;
            c.setDisplaySize(size, size);
            
            // Add this line:
            c.setPosition(this.centerX + c.relX * this.arenaRadius, this.centerY + c.relY * this.arenaRadius);
        });
    });

    this.cursors = this.input.keyboard.addKeys("W,S,A,D,F");

    // --- SOCKET ---
    this.socket = io();
    socket = this.socket;

    this.otherPlayers = this.physics.add.group();
    this.circles = new Map();
    this.zones = new Map();


    // --- creating ---
    socket.on("currentPlayers", players => {
        Object.values(players).forEach(p => {
            if (p.playerId === socket.id) addPlayer(self, p);
            else addOtherPlayers(self, p);
        });
    });

    socket.on("newPlayer", p => addOtherPlayers(self, p));
    socket.on("spawnZones", zonesData => {
    matchStartTime = Date.now();
    zonesData.forEach(z => {
        // Create the Zone Circle
        const zone = self.add.circle(
            self.centerX + z.x * self.arenaRadius, 
            self.centerY + z.y * self.arenaRadius, 
            z.r * self.arenaRadius, 
            z.color, 
            0.3
        );

        zone.id = z.id;
        zone.relX = z.x;
        zone.relY = z.y;
        zone.relR = z.r;

        // 1. ADD PLAYER NAME ABOVE ZONE
        // We position it slightly above the center of the zone
        zone.nameLabel = self.add.text(zone.x, zone.y - (z.r * self.arenaRadius * 0.4), z.ownerName || "Goal", {
            fontSize: `${z.r * self.arenaRadius * 0.25}px`,
            color: "#ffffff",
            fontStyle: "bold",
            stroke: "#000",
            strokeThickness: 2
        }).setOrigin(0.5);

        // 2. EXISTING COUNT TEXT
        zone.countText = self.add.text(zone.x, zone.y, z.count || 0, { 
            fontSize: `${z.r * self.arenaRadius * 0.6}px`, 
            color: "#fff" 
        }).setOrigin(0.5);

        self.zones.set(z.id, zone);
    });
});
    socket.on("spawnCircles", circlesData => {
    const size = self.arenaRadius * 0.04;

    circlesData.forEach(d => {
        const c = self.add.image(
            self.centerX + d.x * self.arenaRadius,
            self.centerY + d.y * self.arenaRadius,
            "egg"
        );

        c.baseSize = size * 2;
        c.setDisplaySize(c.baseSize, c.baseSize);
        c.setOrigin(0.5);

        c.id = d.id;
        c.relX = d.x;
        c.relY = d.y;

        c.floatTween = self.tweens.add({
            targets: c,
            props: {
                y: { value: "-=4", duration: 600 }
            },
            yoyo: true,
            repeat: -1
        });

        self.circles.set(d.id, c);
    });
});
    function addPlayer(self, p) {
    const body = self.add.rectangle(
        self.centerX + p.x * self.arenaRadius,
        self.centerY + p.y * self.arenaRadius,
        self.playerSize,
        self.playerSize,
        p.color
    );

    const nameText = self.add.text(body.x, body.y - self.playerSize, p.name, {
        fontSize: "16px",
        color: "#fff",
        stroke: "#000",
        strokeThickness: 3
    }).setOrigin(0.5);

    self.physics.add.existing(body);

    self.container = body;
    self.nameText = nameText;

    self.player = { playerId: p.playerId, holding: null };
}

    function addOtherPlayers(self, p) {
    const body = self.add.rectangle(
        self.centerX + p.x * self.arenaRadius,
        self.centerY + p.y * self.arenaRadius,
        self.playerSize,
        self.playerSize,
        p.color
    );
    body.targetX = body.x;
    body.targetY = body.y;
    body.holding = null;
    const nameText = self.add.text(body.x, body.y - self.playerSize, p.name, {
        fontSize: "16px",
        color: "#fff",
        stroke: "#000",
        strokeThickness: 3
    }).setOrigin(0.5);

    body.playerId = p.playerId;
    body.nameText = nameText;

    self.otherPlayers.add(body);
    self.physics.add.existing(body);
}
    
    // --- other player server broadcastings ---

    socket.on("stateUpdate", list => {
    list.forEach(p => {
        if (p.id === socket.id) return;

        const o = self.otherPlayers.getChildren().find(x => x.playerId === p.id);
        if (!o) return;

        o.targetX = self.centerX + p.x * self.arenaRadius;
        o.targetY = self.centerY + p.y * self.arenaRadius;
        o.holding = p.holding;
    });
});

    socket.on("circleGrabbed", d => {
        const c = self.circles.get(d.circleId);
        if (c) c.owner = d.playerId;

        self.otherPlayers.getChildren().forEach(o => {
            if (o.playerId === d.playerId) o.holding = d.circleId;
        });

        if (d.playerId === socket.id) self.player.holding = d.circleId;
        if (c && c.floatTween) c.floatTween.pause();
        if (c && c.floatTween) {
            c.floatTween.stop();
            c.floatTween = null;
        }
    });

   socket.on("circleDropped", d => {
    const c = self.circles.get(d.circleId);
    if (!c) return;

    // 1. CRITICAL: Break the link immediately so update() stops moving it
    if (self.player.holding === d.circleId) {
        self.player.holding = null;
    }

    // Also clear it for other players
    self.otherPlayers.getChildren().forEach(o => {
        if (o.holding === d.circleId) o.holding = null;
    });

    c.owner = null;
    c.relX = d.x;
    c.relY = d.y;

    const worldX = self.centerX + d.x * self.arenaRadius;
    const worldY = self.centerY + d.y * self.arenaRadius;

    // 2. Kill the old tween and set position
    if (c.floatTween) c.floatTween.stop(); 
    c.setPosition(worldX, worldY);
    c.setDisplaySize(c.baseSize, c.baseSize);

    // 3. Start a fresh tween at the new location
    c.floatTween = self.tweens.add({
        targets: c,
        y: "-=4",
        duration: 600,
        yoyo: true,
        repeat: -1
    });
});

    socket.on("zoneUpdated", d => {
        const z = self.zones.get(d.zoneId);
        if (z) z.countText.setText(d.count);
    });

    socket.on("gameOver", d => {
    const duration = Math.floor((Date.now() - matchStartTime) / 1000);

    // Assuming d.winner is the playerName string sent from your server
    matchHistory.push({
        winner: d.winner,
        time: duration
    });

    winCounts[d.winner] = (winCounts[d.winner] || 0) + 1;

    // Call the UI function
    showEndUI(d.winner, duration);
});



    socket.on("rematchRequested", data => {
        const btn = document.getElementById("rematchbtn");
        if (!btn) return;

        btn.innerText = `Rematch (${data.count})`;
    });
    socket.on("rematchStart", () => {
        hideGameOverUI();
        resetLocalGame.call(self);
    });

    socket.emit("joinGame", { numPlayers, roomName: roomName || null, playerName: playerName });
}

function update() {
    if (!this.container) return;

    const speed = this.playerSpeed;
    let moved = false;
    if (this.player.holding) {
        const c = this.circles.get(this.player.holding);
        if (c) {
            const holdOffset = this.playerSize * 0.6;

            const tx = this.container.x;
            const ty = this.container.y - holdOffset;

            c.x += (tx - c.x) * 0.6;
            c.y += (ty - c.y) * 0.6;
            c.lastX = c.x;
            c.lastY = c.y;

            c.setDisplaySize(c.baseSize * 1.1, c.baseSize * 1.1);
        }
    }
    if (this.nameText) {
        this.nameText.setPosition(this.container.x, this.container.y - this.playerSize);
    }
    // --- move held circles for OTHER players ---
    this.otherPlayers.getChildren().forEach(o => {
    if (o.targetX !== undefined) {
        o.x += (o.targetX - o.x) * 0.2;
        o.y += (o.targetY - o.y) * 0.2;
        o.nameText.setPosition(o.x, o.y - this.playerSize);
    }

    if (o.holding) {
        const c = this.circles.get(o.holding);
        if (c) {
            const holdOffset = this.playerSize * 0.6;
            const tx = o.x;
            const ty = o.y - holdOffset;

            c.x += (tx - c.x) * 0.6;
            c.y += (ty - c.y) * 0.6;
                    }
    }
});
    // --- TOUCH MOVE ---
    const fx = this.joyData.forceX;
const fy = this.joyData.forceY;

if (Math.abs(fx) > 0.01 || Math.abs(fy) > 0.01) {
    this.container.x += fx * this.playerSpeed;
    this.container.y += fy * this.playerSpeed;
    moved = true;
}

    // --- KEYBOARD MOVE ---
    if (this.cursors.A.isDown) { this.container.x -= speed; moved = true; }
    if (this.cursors.D.isDown) { this.container.x += speed; moved = true; }
    if (this.cursors.W.isDown) { this.container.y -= speed; moved = true; }
    if (this.cursors.S.isDown) { this.container.y += speed; moved = true; }

    // --- LIMIT TO ARENA ---
    const dx = this.container.x - this.centerX;
    const dy = this.container.y - this.centerY;
    const dist = Math.hypot(dx, dy);
    if (dist > this.arenaRadius) {
        const a = Math.atan2(dy, dx);
        this.container.x = this.centerX + Math.cos(a) * this.arenaRadius;
        this.container.y = this.centerY + Math.sin(a) * this.arenaRadius;
    }

    // --- SEND MOVE ---
    if (moved) {
        const now = Date.now();
        if (now - lastSend > SEND_RATE) {
            socket.emit("playerMovement", { 
                x: (this.container.x - this.centerX) / this.arenaRadius, 
                y: (this.container.y - this.centerY) / this.arenaRadius 
            });
            lastSend = now;
        }
    }
    // --- GRAB ---
    if (Phaser.Input.Keyboard.JustDown(this.cursors.F))
    {
        socket.emit("toggleGrab");
    }
    // Server sends updated circle positions

}
function resetLocalGame() {
    matchStartTime = Date.now();
    // reset player
    if (this.container) {
        this.container.setPosition(this.centerX, this.centerY);
    }
    if (this.player) {
        this.player.holding = null;
    }

    // destroy circles
    this.circles.forEach(c => c.destroy());
    this.circles.clear();

    // destroy zones
    this.zones.forEach(z => {
        z.destroy();
        z.countText.destroy();
    });
    this.zones.clear();
}
function showEndUI(winner, duration) {
    document.getElementById("endUI").style.display = "flex";
    document.getElementById("winnerText").innerText = `Winner: ${winner}`;

    let html = `<h3>Scoreboard</h3>`;

    for (let p in winCounts) {
        html += `<div>üèÜ ${p}: ${winCounts[p]} wins</div>`;
    }

    html += `<hr><h3>Match History</h3>`;

    matchHistory.forEach((m, i) => {
        html += `<div>#${i + 1} ‚Äî ${m.winner} ‚Äî ${m.time}s</div>`;
    });

    document.getElementById("statsBox").innerHTML = html;
}
function hideGameOverUI() {
    document.getElementById("endUI").style.display = "none";
    document.getElementById("winnerText").innerText = "";
    const btn = document.getElementById("rematchbtn");
    btn.disabled = false;
    btn.innerText = "Rematch";
}

function playAgain() {
    const btn = document.getElementById("rematchbtn");

    socket.emit("requestRematch");
    // disable after clicking
    btn.disabled = true;
    btn.innerText = "Waiting...";
}
function goHome() { socket.emit("leaveRoom"); window.location.href = "/index.html"; }
</script>
</body>
</html>